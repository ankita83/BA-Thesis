# using the standoff format generated by conll_to_standoff.py, generate the collection object and
# the document object. These objects are needed by the xhtml to view the dependency tree of a sentence/text
# using the brat nlp.

import re
from pprint import pprint

pattern1 = re.compile("^T[0-9]+$")
pattern2 = re.compile("^R[0-9]+$")

# open the .ann file created by conllXtostandoff.py
#file = open('brat_sample.txt-doc-1.ann', 'r')
#lines = file.readlines()

def createBratObjects(bratformat, selectedWord, selectedRel):
    entity_objects = []
    relation_objects = []
    for l in bratformat:
        l = l.splitlines()[0]
        fields = re.split('\s+', l)

        if pattern1.match(fields[0]):
            entity_objects.append(fields)
        elif pattern2.match(fields[0]):
            relation_objects.append(fields)

    pprint(entity_objects)
    pprint(relation_objects)

    collData = createCollData(entity_objects, relation_objects, selectedWord, selectedRel)
    docData = createDocData(entity_objects, relation_objects)

    return [collData, docData]

def createCollData(entity_objects, relation_objects, selectedWord, selectedRel):
    e_type_objects = []
    pprint(selectedWord)
# e[1] is the label (eg: NOUN), e[4] is the word (eg: cat)
    for e in entity_objects:
        if e[4] in selectedWord:
            color = "#f9075c"
        else:
            color = "#7fa2ff"
        entry = {
            'type': e[1],
            'labels': [e[1]],
            'bgColor': '%s' %color,
            'borderColor': 'darken'
        }
        e_type_objects.append(entry)


    r_type_objects = []
    for r in relation_objects:
        if r[1] in selectedRel:
            color = "red"
        else:
            color = "purple"
        target1 = ""
        target2 = ""
        x = str(r[2].split(':')[1])
        y = str(r[3].split(':')[1])
        for e in entity_objects:
            if e[0] == x:
                target1 = str(e[1])
            if e[0] == y:
                target2 = str(e[1])
        arg1 = {
            'role':'Arg1',
            'targets': [target1]
        }
        arg2 = {
            'role':'Arg2',
            'targets': [target2]
        }
        entry = {
            'type': r[1],
            'labels': [r[1]],
            'dashArray': '3,3',
            'color': '%s' %color,
            'args': [arg1, arg2]
        }
        r_type_objects.append(entry)

    collData = {
       'entity_types': e_type_objects,
       'relation_types': r_type_objects
    }
    pprint(collData)
    return collData

def createDocData(entity_objects, relation_objects):
    text = ""
    entities = []
    for e in entity_objects:
        entry = [e[0], e[1], [[e[2], e[3]]]]
        entities.append(entry)
        text = text + str(e[4]) + " "

    relations = []
    for r in relation_objects:
        entry = [r[0], r[1], [[str(r[2].split(':')[0]), str(r[2].split(':')[1])],
                             [str(r[3].split(':')[0]), str(r[3].split(':')[1])]]]
        relations.append(entry)

    docData = {
       'text': text,
       'entities': entities,
       'relations': relations
    }
    print docData
    return docData


#--------------------------------------------------------
